---
layout: post
title: 操作系统老兵：软件生态为什么难度这么大？
categories: [Think]
---

很多没做过操作系统的，很容易受到抖音民族情绪渲染调动，就认为只要有人就可以把操作系统干好，真实的软件生态要比你想象的难很多。

为了方便大家理解，我尽量简化其中的逻辑，只说我几十年经验的结论。

操作系统的生态主要有 5 个方面：
1. 芯片
2. 编译器
3. 基础软件组件
4. 操作系统
5. 关键软件生态

芯片最难的其实不仅仅是大家熟知的制程和工艺，最难的是指令集。一个不开放的指令集，会导致很多开源软件的代码分支没有这种指令集。而现代操作系统早已离不开开源软件，没有对应的指令集，基本上就要对每个开源组件都手动增加指令集分支的代码，而指令集分支的代码是大量的 #ifdef 代码，50个人折腾一年后，一旦上游软件改了代码，手动迁移适配的工作量极大，就像一提花生一样，一环套一环。大家说，为什么不贡献设备到开源社区？因为一个用的很少的芯片，对于上游开发者也是负担，没人用，每天还要维护这个分支的代码，累。

编译器是开源社区很难理解的难，因为编译器和芯片指令集是绑定的。开源社区大家升级 GCC 版本觉得很简单，但是一个新的芯片的编译器和芯片的指令集相关。因为你芯片做了任何创新，比如多媒体指令，向量加速指令，AI 算子加速指令等等。这些都需要通过编译器翻译，才能让软件用得上这些指令集。所以，你要大量改 GCC，让软件编译的时候自动能用上这些新的指令集，这里工作量巨大。最难的还不是这里，而是 GCC 影响的底层软件太多了，不能有 bug，如果有 bug 会导致你以前编译的软件要全部重新编译，不要问我为什么知道，说多都是泪。 操作系统的基础软件重新编译一遍最少需要 1 个月的时间，比 LFS 难一万倍。

基础软件组件，比如性能分析工具、浏览器引擎、Python、各种数学库。基础软件最麻烦的就是这些带数学库的软件，现代很多先进编程语言的指令集优化不受 GCC 影响，比如 golang，haskell 都自带编译器和数学库，这些语言的移植和上面 GCC 一样难，需要既懂 X86 指令集，又要懂新的芯片指令集，还需要熟悉新的编程语言，还要数学功底强。虽然没有 GCC 影响面大，但是工作量非常大，专业编译器团队也要花一年时间才能稳定一个版本。

操作系统相对于前面三个来说，虽然底层难度不大，但是上层的难度在于应用软件的支持和用户习惯。想要说服成千上万的软件厂商维护你操作系统的版本非常难，你首先要证明你用户量大，否则没人支持。 而你面对的是先有鸡还是先有蛋的问题。而自己造的话，只能造一些通用软件。比如专业点的，Office、CAD、PS 等，操作系统厂商本身也不专业，因为你软件工程能力再强，也缺乏这些行业多年的行业认知。

关键基础软件生态，最典型就是类似 CUDA 这种护城河。即使你跨越了前面几座高山，每座高山都损失 30% 的性能，到了专业赛道以后，想要弯道超车非常非常的难。因为别人用 CUDA 搞钱，你想要别人当小白鼠，基本没人会理你。

而操作系统软件生态最难的是，用户和行业的习惯，他们习惯于某一个生态的文档，习惯于出了问题网上可以抄答案。 来到一个新的生态， 99% 的厂商都没有底层软件调试能力，一个出错可以保证你全网都没有一篇解决方案，最后生态合作伙伴的老板每天思考的问题是，等你平台跑起来，我都饿死了。

所以，操作系统的软件生态发展只有两条路：
1. 浪潮： 新的赛道，新的浪潮，所有人都是 0 起步，只要可以赚钱，再烂的操作系统都有人用，比如智能手表，智能门锁，电动汽车等
2. 补贴： 国家巨大的补贴，生态发展起来了给国家省钱和增加贸易谈判筹码，但是结果大家也知道，补贴的市场容易缺乏长远竞争力

懒猫微服的操作系统是我们耗时 3 年研发，瞄准家庭服务器和 AI Agent 赛道，三层操作系统架构设计，怎么折腾都不会挂，商店 1000 多个应用，好玩好用。 

欢迎开发者们找我购买，开发者有专属优惠。不是开发者怎么办？ 5.1期间有24期免息优惠，每个月只需 200 元即可拥有。 https://item.jd.com/10101262547531.html
