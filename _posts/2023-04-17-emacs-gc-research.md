---
layout: post
title: Emacs GC 的一些研究
categories: [Emacs]
---

Emacs GC 一直是卡顿 Emacs 的主要元凶。

今天花了一点时间研究了 Emacs GC 的源代码 `emacs/src/alloc.c`, 关键代码在 `garbage_collect` 这个函数, 其代码实现的核心流程如下：

1. 阻止用户输入: GC 操作之前先调用 `block_input` 函数阻止用户输入, 并把 GC 标志位 `gc_in_progress` 设置为 1
2. 标记可达对象： 用 `visit_static_gc_roots` 和各种 `mark_xx` 函数， 扫描 Emacs 的一些根对象（比如全局函数定义、 变量定义、 Buffer 列表等）， 最后通过函数 `mark_object` 把这些对象标记为‘可达’
3. 清理垃圾对象： 通过 `gc_sweep` 函数按照对象的类型（string, cons, float, interval, symbol, buffer, vector 等）进行扫描， 查看没有被第二步标记的对象， 释放其内存
4. 允许用户输入： 通过`unblock_input`函数解除输入阻止， 把 GC 标志位`gc_in_progress`设置为 0， 完成垃圾回收

Emacs 这种全局扫描的垃圾对象的算法策略， 主要的问题是， 随着 Emacs 对象增多（主要是 LSP 或 overlay 场景下短时间生成大量对象）时， 第二步标记和第三步清理的耗时会随着对象数量急剧增加， 一旦这两个过程的耗时超过 30~100 毫秒， 就会产生 Emacser 遇到的卡手现象， 如果这个过程超过 2 秒以上， 就会导致用户极度烦躁甚至强制 kill。

因为 Emacs 本身是单线程程序， 所以我们没办法把 GC 过程放到后台线程去跑。

所以， 针对 GC 性能优化， 我自己想了几个研究方向：

1. 随时中断 GC： 在 `garbage_collect` 过程中插入大量 `detect_input_pending` 判断， 如果 GC 过程中检测到用户有输入事件发生， 立即中断 GC 过程, 避免 GC 导致 Emacs 无法响应用户操作
2. 双进程模型： 需要进行 GC 时， 通过类似 pdumper 的技术， 把当前 Emacs 的内存保存到磁盘中（为了性能可以用内存文件）， 然后再根据 dump 文件开一个后台 Emacs 进程， 通过后台 Emacs 进程慢慢分析需要清理的对象， 分析完成发送清理列表给第一个 Emacs 进程进行清理
3. 分代回收： 根据对象的创建时间进行分代分析， 那些创建时间非常短的对象（一般是临时变量）优先分析， 那些创建时间比较长的对象延迟分析（一般是插件引入的全局函数或者变量）， 降低每次全局垃圾对象分析的规模

这三种方式的优缺点分析：
1. 第一种， 就是比较简单粗暴， 随时中断 GC 以保持用户操作响应， 用户频繁输入的时候 GC 基本没有机会运行， 用户暂停的时候 GC 可以尽情的运行， 为了避免标记和清除的过程也卡住用户， 可以在 `mark_xx` 和 `gc_sweep` 函数里面继续插入大量 `detect_input_pending` 判断， 只要 `detect_input_pending` 插入细粒度越细， 理论上可以做到 GC 不卡用户； 缺点是随时中断 GC 需要做很多状态恢复和代码保护， 避免 Emacs 崩溃（今天晚上已经尝试了第一种方法， 因为时间不够， 各种崩溃， 哈哈哈哈）
2. 第二种， 就是第一个 Emacs 完全不做 GC 分析， 让第二个进程做 GC 分析， 要卡也卡第二个 Emacs， 这种方案的优点是 Emacs 开发者不用关心 GC 兼容性问题， 正常写代码逻辑就好了， 缺点是比较占用内存资源， 或者让一部分 Emacser 洁癖用户心理不舒服
3. 第三种， 通过时间戳或者 let 表达式进行创建时间标注， 避免让 Emacs 对一些常驻对象（比如插件引入的函数定义和全局变量等）进行检查, 多分析临时对象， 提高 GC 效率， 缺点是， 要大量改造 Emacs GC 代码， 难度到没啥， 主要是测试工作量比较大

以上是一些关于 Emacs GC 的研究， 因为时间关系， 很难在短时间内有进展， 前期只能先理理思路， 把思路分享出来抛砖引玉, 欢迎大家一起讨论贡献智慧。
