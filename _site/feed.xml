<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-07-05T00:26:29+08:00</updated><id>http://localhost:4000/feed.xml</id><entry><title type="html">MacBook Pro的键盘被我敲碎了</title><link href="http://localhost:4000/mac/tech/2019/07/04/fuck-mackbook-keyboard.html" rel="alternate" type="text/html" title="MacBook Pro的键盘被我敲碎了" /><published>2019-07-04T00:00:00+08:00</published><updated>2019-07-04T00:00:00+08:00</updated><id>http://localhost:4000/mac/tech/2019/07/04/fuck-mackbook-keyboard</id><content type="html" xml:base="http://localhost:4000/mac/tech/2019/07/04/fuck-mackbook-keyboard.html">&lt;p&gt;都说Mac笔记本的键盘渣，最开始我一直以为只是手感差，论键盘手感，只有老款的ThinkPad的键盘手感才算过得去。&lt;/p&gt;

&lt;p&gt;在MacBook Pro上写代码的时候，能明显地感觉到MacBook Pro那可怜的键盘回弹，敲上去总是给人一种非常脆弱的感觉。
为了不把Mac笔记本的键盘敲坏，我一直小心翼翼的按键，生怕哪一天这个键盘罢工了。&lt;/p&gt;

&lt;p&gt;人算不如天算啊，MacBook Pro用了刚好一年，J这个按键已经被我敲碎了，完全没法用了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fuck-macbook-keyboard/1.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而且我有预感，其他按键过一段时间也会步J按键的后尘，为了保险，下午去了一趟苹果售后，售货人员直接说，换整个键盘3000，换一个键帽几大百。
真黑心啊，自己动手丰衣足食，我在淘宝上花了35元买了一整套键帽，等键帽回来自己动手换。&lt;/p&gt;

&lt;p&gt;在键帽到之前，我估计要背着我的IKBC机械硬盘几天了，晚上回家把机械键盘插上MacBook Pro后，完全一脸懵逼，
Mac无法正确映射IKBC的键盘布局，导致快捷键不兼容后我完全没法使用Emacs。&lt;/p&gt;

&lt;p&gt;研究了一下 Karabiner Elements 这个专业换快捷键利器，搞定了问题：&lt;/p&gt;

&lt;p&gt;首先把MacBook Pro内置的Fn和Ctrl键交换了，我喜欢左下角就是Ctrl按键的踏实感&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fuck-macbook-keyboard/2.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其次把IKBC机械键盘的左Ctrl、左Win、左Alt键做一个映射，解决MacBook Pro映射错键位的问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fuck-macbook-keyboard/3.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后设置当IKBC机械键盘插入时，禁用MacBook Pro的内置键盘，这样我就可以把机械键盘放到笔记本上敲而不会触发笔记本的内置键盘&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fuck-macbook-keyboard/3.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过上面三个步骤的设置后，我又可以非常流畅的使用Emacs了，忍受了一年MacBook Pro的垃圾键盘，终于又体会到机械键盘写代码的快乐了。&lt;/p&gt;

&lt;p&gt;我估计等MacBook Pro键帽换好以后，我还是会背着机械键盘走天下。&lt;/p&gt;</content><author><name></name></author><summary type="html">都说Mac笔记本的键盘渣，最开始我一直以为只是手感差，论键盘手感，只有老款的ThinkPad的键盘手感才算过得去。</summary></entry><entry><title type="html">highlight-matching-tag.el 实时高亮匹配标签</title><link href="http://localhost:4000/emacs/2019/06/27/highlight-matching-tag.html" rel="alternate" type="text/html" title="highlight-matching-tag.el 实时高亮匹配标签" /><published>2019-06-27T00:00:00+08:00</published><updated>2019-06-27T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/06/27/highlight-matching-tag</id><content type="html" xml:base="http://localhost:4000/emacs/2019/06/27/highlight-matching-tag.html">&lt;p&gt;昨天花了一个小时给Emacs写了实时重命名Tag的插件&lt;a href=&quot;https://manateelazycat.github.io/emacs/2019/06/26/instant-rename-tag.html&quot;&gt;instant-rename-tag&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今天就在想，能否基于同样原理写一个实时高亮匹配标签的插件呢？&lt;/p&gt;

&lt;h3 id=&quot;highlight-matching-tagel-的原理&quot;&gt;highlight-matching-tag.el 的原理&lt;/h3&gt;

&lt;p&gt;highlight-matching-tag的原理和instant-rename-tag完全是一样的，只是绑定了不同的事件hook&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;post-command-hook&lt;/code&gt; 监听光标移动事件，如果当前处于 &lt;code class=&quot;highlighter-rouge&quot;&gt;web-mode&lt;/code&gt; 模式时继续处理&lt;/li&gt;
  &lt;li&gt;如果光标在Tag区域，找到匹配的光标，然后用 Overlay 高亮匹配的标签&lt;/li&gt;
  &lt;li&gt;如果光标不在Tag区域，隐藏标签高亮&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/highlight-matching-tag/highlight-matching-tag.gif&quot; alt=&quot;highlight-matching-tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装方法见&lt;a href=&quot;https://github.com/manateelazycat/highlight-matching-tag&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;
&lt;p&gt;安装好只用调用命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;(highlight-matching-tag 1)&lt;/code&gt; 即可&lt;/p&gt;</content><author><name></name></author><summary type="html">昨天花了一个小时给Emacs写了实时重命名Tag的插件instant-rename-tag</summary></entry><entry><title type="html">instant-rename-tag.el 实时修改Tag名</title><link href="http://localhost:4000/emacs/2019/06/26/instant-rename-tag.html" rel="alternate" type="text/html" title="instant-rename-tag.el 实时修改Tag名" /><published>2019-06-26T00:00:00+08:00</published><updated>2019-06-26T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/06/26/instant-rename-tag</id><content type="html" xml:base="http://localhost:4000/emacs/2019/06/26/instant-rename-tag.html">&lt;p&gt;最近在研究VSCode好用的功能，希望通过一点点的努力, 把VSCode好的功能吸收到Emacs。&lt;/p&gt;

&lt;p&gt;说到VSCode，说它是支持Web编程最好的IDE一点也不为过，其中实时修改Tag名字的功能非常好用。&lt;/p&gt;

&lt;p&gt;可惜的是，Emacs一直都没有好用的实时修改Tag的功能，即使最强大的 web-mode 也需要从 minibuffer 中读取新的Tag，视线要在光标处和minibuffer来回跳动，不够爽。&lt;/p&gt;

&lt;p&gt;以前类似的插件在原理上总是希望修改Tag的时候，实时的计算匹配的Tag区域并同步更新，这样的实现原理是有问题:&lt;/p&gt;

&lt;p&gt;因为不管是 sgml-mode 还是 web-mode, 一旦发现Tag不匹配，就很难找到匹配Tag区域，究其原因是Emacs找到匹配的Tag区域是基于正则查找, 所以一旦Tag无法匹配，实时修改Tag的功能实现就很困难，而且在复杂的Emacs插件环境中特别容易出错。&lt;/p&gt;

&lt;h3 id=&quot;instant-rename-tagel-的原理&quot;&gt;instant-rename-tag.el 的原理&lt;/h3&gt;

&lt;p&gt;instant-rename-tag 认识到上面的问题，从实现上放弃了Tag实时匹配查找的策略，而是用下面的步骤来实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;重命名动作触发的时候，根据 Open Tag 还是 Close Tag的位置，找到匹配的Tag区域&lt;/li&gt;
  &lt;li&gt;用 Overlay 来保存 Open Tag 和 Close Tag 的区域，一旦保存好以后，就不再进行任何Tag匹配的搜索&lt;/li&gt;
  &lt;li&gt;监控光标插入，如果当前光标是在 Tag Overlay 区域修改，比如 &amp;lt;div&amp;gt; Tag中修改，会去找 &amp;lt;/div&amp;gt; 的 Overlay&lt;/li&gt;
  &lt;li&gt;找到对应的 Tag Overlay, 同步其内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样只在重命名启动的时候查找一下 Tag 的区域，后面只是简单的光标监控和内容同步，既实现了实时改名的功能，又不会因为Tag不匹配产生很多乱改用户buffer的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/instant-rename-tag/instant-rename-tag.gif&quot; alt=&quot;instant-rename-tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装方法见&lt;a href=&quot;https://github.com/manateelazycat/instant-rename-tag&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;
&lt;p&gt;使用方法很简单, 绑定按键到 &lt;code class=&quot;highlighter-rouge&quot;&gt;instant-rename-tag&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;想修改Tag名字的时候，调用一次 instant-rename-tag, 修改完成后只用把光标移动到非Tag区域继续编辑，刚刚重命名的区域会自动取消标记。&lt;/p&gt;</content><author><name></name></author><summary type="html">最近在研究VSCode好用的功能，希望通过一点点的努力, 把VSCode好的功能吸收到Emacs。</summary></entry><entry><title type="html">smart-align.el 代码自动对齐插件</title><link href="http://localhost:4000/emacs/2019/06/24/smart-align.html" rel="alternate" type="text/html" title="smart-align.el 代码自动对齐插件" /><published>2019-06-24T00:00:00+08:00</published><updated>2019-06-24T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/06/24/smart-align</id><content type="html" xml:base="http://localhost:4000/emacs/2019/06/24/smart-align.html">&lt;p&gt;像VSCode和很多IDE都具备快速对齐赋值表达式的功能。&lt;/p&gt;

&lt;p&gt;Emacs其实有更强大的 align-regexp 功能，可以让用户对选中的内容进行自定义正则对齐。
只要正则表达式玩的溜，最后实现的功能比VSCode等IDE还要强大。&lt;/p&gt;

&lt;p&gt;比如 Emacs 中要进行对齐操作，一般需要三个步骤:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;选中一段代码区域&lt;/li&gt;
  &lt;li&gt;调用 align-regexp 命令&lt;/li&gt;
  &lt;li&gt;写入需要对齐的赋值符号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是在实际编程中，大部分都是对齐赋值表达式，赋值的符号一般都是 = 或者 :
并不会有非常复杂的规则需要开发者去编写正则表达式完成对齐操作。
所以这时候 Emacs 的步骤就非常繁琐，特别是还需要手动选择需要对齐的代码区域，用户体验非常不好。&lt;/p&gt;

&lt;p&gt;针对上面的情况，写了 smart-align 这个插件，会自动选择当前光标处的代码块，一键就可以自动对齐代码块内的所有内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/smart-align/smart-align.gif&quot; alt=&quot;smart-align&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装方法见&lt;a href=&quot;https://github.com/manateelazycat/smart-align&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;
&lt;p&gt;使用方法很简单, 绑定按键到 &lt;code class=&quot;highlighter-rouge&quot;&gt;smart-align&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码贡献&quot;&gt;代码贡献&lt;/h3&gt;
&lt;p&gt;现在代码实现只是简单的用 &lt;code class=&quot;highlighter-rouge&quot;&gt;backward-up-list&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;up-list&lt;/code&gt; 自动选择光标外的一层语法块，
如果语法块内每一行都是赋值表达式，这个插件会工作的非常好。&lt;/p&gt;

&lt;p&gt;但是如果语法块内有某一行不是赋值表达式， &lt;code class=&quot;highlighter-rouge&quot;&gt;align-regexp&lt;/code&gt; 函数就会失效，无法对代码进行自动对齐。&lt;/p&gt;

&lt;p&gt;正确的思路应该是在语法块内进一步搜索来进一步定位包含 = 或者 : 的子语法块范围，再依次传给 &lt;code class=&quot;highlighter-rouge&quot;&gt;align-regexp&lt;/code&gt;
欢迎各大高手来一起 &lt;a href=&quot;https://github.com/manateelazycat/smart-align/edit/master/smart-align.el&quot;&gt;完善&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">像VSCode和很多IDE都具备快速对齐赋值表达式的功能。</summary></entry><entry><title type="html">AwesomeTab支持图标显示了</title><link href="http://localhost:4000/emacs/2019/06/23/awesome-tab-support-icon.html" rel="alternate" type="text/html" title="AwesomeTab支持图标显示了" /><published>2019-06-23T00:00:00+08:00</published><updated>2019-06-23T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/06/23/awesome-tab-support-icon</id><content type="html" xml:base="http://localhost:4000/emacs/2019/06/23/awesome-tab-support-icon.html">&lt;p&gt;自从发布 &lt;a href=&quot;https://github.com/manateelazycat/awesome-tab&quot;&gt;AwesomeTab&lt;/a&gt; 这个Emacs最好的标签插件以后，很多社区的高手陆续地在给这个项目贡献建议和补丁。&lt;/p&gt;

&lt;p&gt;头两天接到一个国外开发者的 &lt;a href=&quot;https://github.com/manateelazycat/awesome-tab/issues/34&quot;&gt;issue&lt;/a&gt;, 提出了想在标签上显示图标的功能，今天早上思考了5分钟, 写了一个补丁: &lt;a href=&quot;https://github.com/manateelazycat/awesome-tab/commit/ae98cef5c9fe2b8674c705f1772400f0caf10a74&quot;&gt;让AwesomeTab支持图标渲染&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;只要 &lt;a href=&quot;https://github.com/domtronn/all-the-icons.el&quot;&gt;AllTheIcons&lt;/a&gt; 这个图标插件安装好以后， AwesomeTab会自动在标签上渲染对应的文件图标。&lt;/p&gt;

&lt;p&gt;最终的效果图如下：
&lt;img src=&quot;http://localhost:4000/pics/awesome-tab/support-icons.png&quot; alt=&quot;AwesomeTab&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这就是开源社区的魅力，每天只做一点点，滴水石穿就能做出非常好的软件。&lt;/p&gt;</content><author><name></name></author><summary type="html">自从发布 AwesomeTab 这个Emacs最好的标签插件以后，很多社区的高手陆续地在给这个项目贡献建议和补丁。</summary></entry><entry><title type="html">代码语法块删除插件</title><link href="http://localhost:4000/emacs/2019/06/22/delete-block.html" rel="alternate" type="text/html" title="代码语法块删除插件" /><published>2019-06-22T00:00:00+08:00</published><updated>2019-06-22T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/06/22/delete-block</id><content type="html" xml:base="http://localhost:4000/emacs/2019/06/22/delete-block.html">&lt;h3 id=&quot;代码语法块删除插件&quot;&gt;代码语法块删除插件&lt;/h3&gt;
&lt;p&gt;一般来说我们会用 &lt;code class=&quot;highlighter-rouge&quot;&gt;forward-word&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;backward-word&lt;/code&gt; 这两个命令快速在Emacs中进行单词移动。
如果开启了 &lt;code class=&quot;highlighter-rouge&quot;&gt;subword-mode&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;forward-word&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;backward-word&lt;/code&gt; 会在骆驼风格的单词中按子单词的范围进行移动。
比如 FooBarExample 这个单词，移动的范围依次是 Foo Bar Example&lt;/p&gt;

&lt;p&gt;今天写了一个插件，主要融合 &lt;code class=&quot;highlighter-rouge&quot;&gt;skip-syntax-forward&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;skip-syntax-backward&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;subword-mode&lt;/code&gt; , 使得Emacs可以快速向左和向右进行语法块删除，同时遇到骆驼风格单词的时候可以快速删除子单词。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/delete-block/delete-block.gif&quot; alt=&quot;delete-block&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装方法见&lt;a href=&quot;https://github.com/manateelazycat/delete-block&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;

&lt;p&gt;使用方法很简单, 绑定按键到下面几个函数:&lt;/p&gt;
&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;delete-block-forward&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;delete-block-backward&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">代码语法块删除插件 一般来说我们会用 forward-word 和 backward-word 这两个命令快速在Emacs中进行单词移动。 如果开启了 subword-mode , forward-word 和 backward-word 会在骆驼风格的单词中按子单词的范围进行移动。 比如 FooBarExample 这个单词，移动的范围依次是 Foo Bar Example</summary></entry><entry><title type="html">Emacs黑客列表</title><link href="http://localhost:4000/emacs/2019/05/12/emacs-hackers.html" rel="alternate" type="text/html" title="Emacs黑客列表" /><published>2019-05-12T00:00:00+08:00</published><updated>2019-05-12T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/05/12/emacs-hackers</id><content type="html" xml:base="http://localhost:4000/emacs/2019/05/12/emacs-hackers.html">&lt;p&gt;当你把Elisp完全学会并且可以写Emacs插件以后，你下一阶段的提升方法就是多向世界著名的Emacs黑客去学习，学习他们的代码细节，学习他们的思考方式和生活态度。&lt;/p&gt;

&lt;p&gt;我这么多年Emacs黑客教会我最大价值的东西就是好奇心和眼界，他们总是用更为简单和贴近本质的方式去解决原来我认为非常困难甚至不可能的事情, 以此激励我不断的学习和重新思考。&lt;/p&gt;

&lt;p&gt;本文希望用博客的方式列出当今世界上著名的Emacs黑客，集中的展示他们的网站，作品和博客，以方便国人更快地提升自己的Emacs水平。&lt;/p&gt;

&lt;p&gt;如果你知道厉害的Emacs黑客不存在下面的列表中，欢迎提交你的 &lt;a href=&quot;https://github.com/manateelazycat/manateelazycat.github.io/edit/master/_posts/2019-05-12-emacs-hackers.md&quot;&gt;补丁&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Richard Stallman&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;Emacs作者, GCC, GDB和很多自由软件的第一作者，自由软件基金会，GNU项目，GPL的创始人， Open Source的奠基人，顶尖的Lisp黑客, 关于教主的生平，相信也无需赘述.
江湖有传言:平生不识RMS，就称Coder也枉然&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://www.emacswiki.org/emacs/RichardStallman&quot;&gt;EmacsWiki&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Richard_Stallman&quot;&gt;Wiki&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://stallman.org/&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Alex Schroeder&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;EmacsWiki管理员，资深Emacs黑客，超级混血王子，精通多国语言，1/16的中国血统，不管哪个国家的Emacs黑客在EmacsWiki注册主页时，他都能用母语去欢迎他们。&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://www.emacswiki.org/emacs/Alex_Schroeder&quot;&gt;EmacsWiki&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://alexschroeder.ch/wiki/Recent_Changes&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Sacha Chua&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;每周都会整理Emacs的新插件，开发进度，新技巧，基本是现在最好的Emacs资讯聚合地，每周的更新我都会看，经常会发现一些非常实用的插件和技巧。最好玩的就是她的名字我总是记不住，总是依靠Google来搜索她的博客。;)&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://sachachua.com/blog/category/geek/emacs/&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Taylor Campbell&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;ParEdit的作者，Emacs插件开发者必备插件， ParEdit的出现极大的推进了Elisp的编程效率，标准的Old School，网上信息极少，但是编程功力惊人。
顺便推广一下 ParEdit 的继任者 &lt;a href=&quot;https://github.com/manateelazycat/awesome-pair&quot;&gt;Awesome-Pair&lt;/a&gt;， 哈哈哈哈。&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://www.emacswiki.org/emacs/TaylorCampbell&quot;&gt;EmacsWiki&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;rubikitch&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;高产的Emacs黑客，开发和维护了大量的Emacs插件，Anything（Helm前身）的核心开发者，Ruby玩的超级溜。典型的日本黑客，Emacs核心开发者中日本开发者占了相当大的比例。&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://www.emacswiki.org/emacs/rubikitch&quot;&gt;EmacsWiki&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;http://rubikitch.com/&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Thierry Volpiatto&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;著名Helm框架的作者，还记得当年我和rubikitch以及Thierry Volpiatto共同开发Anything的那些时光，一个Wiki一个Ediff即可完成三人协作。Thierry Volpiatto这么多年靠一次次的重构，把Anything的思想不断提升精炼， 变成Emacs最流行的搜索补全框架，证明了一个开源项目，数十年如一日的坚持维护是多么的重要。Thierry Volpiatto的主业是攀岩，40多岁才开始学编程，真正的黑客是具有极强的好奇心和冒险精神，Linux内核开发者有牙医，Emacs开发者不但有攀登者，还有阿桑奇这样的斗士，这才是真正黑客的精彩生活，多么令人赞叹！&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://github.com/thierryvolpiatto&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://sachachua.com/blog/2018/09/interview-with-thierry-volpiatto/&quot;&gt;Interview with Thierry Volpiatto&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Matsushita Akihisa&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;color-moccur.el的作者，这个人太低调，他的插件是我最早通过 Google ftp 语法才能搜索到，第一次用 color-moccur.el 的时候太惊叹了，Emacs还可以这样高效率的递归搜索和重构？&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://www.emacswiki.org/emacs/Matsushita&quot;&gt;EmacsWiki&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;John Wiegley&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;use-package作者和Haskell黑客，开发了众多的Emacs插件，虽然我不用use-package, 但单单从Emacs社区推广看，use-package极大的减少了Emacs新手的入门门槛，可以通过一种标准化的配置风格把Emacs的配置经验从老手传递给新手，而不是像Emacs黑客一贯的自由风格，东抄抄西抄抄。&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;http://www.newartisans.com/&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://github.com/jwiegley&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Jonas Bernoulli&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;Emacs顶级杀手锏Magit的作者，如果没有Magit你会人工记忆各种复杂的Git命令，而且很多高级操作需要很多Git Workflow串联配合才搞的定。Magit可以让你只用记住快捷键，就可以玩各种Git骚操作，Emacs必备插件，强烈推荐。
这家伙也会开发一些非常有意思的小插件。&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://github.com/tarsius&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://emacsair.me/&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Carsten Dominik&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;Emacs另一个顶级杀手锏org-mode的作者，荷兰阿姆斯特丹大学天文学教授，org-mode是GTD个人管理工具集大成者，只要你用心玩，你会发现个人记笔记和时间管理可以做到极致。当然有时候也会因为org-mode玩org-mode，org-mode不仅仅是个人任务管理工具，还最擅长写文章导出自己的博客。也是当年他的帮助，我可以快速的签署FSF纸质,给Emacs贡献了 org-w3m.el 这个插件。&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://staff.fnwi.uva.nl/c.dominik/&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://orgmode.org/&quot;&gt;Org-mode&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Dmitry Gutov&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;著名代码补全插件company-mode的作者, Emacs最著名的代码补全框架有auto-complete和company-mode，但就像Anything和Helm的发展历史一样，company-mode因为维护的更久更规范，现在company-mode应该是Emacs最好用也最全面的代码补全插件了。&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://company-mode.github.io/&quot;&gt;company-mode&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://github.com/dgutov&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Oleh Krehel&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;Ivy，Hydra，Avy等一系列有名插件的开发者，想象力丰富的一名荷兰人。他刷新了许多人使用Emacs的习惯，让人感叹Emacs还能这么用！&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://github.com/abo-abo&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://oremacs.com&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Alan Mackenzie&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;这位大神维护cc-mode已近20年。直到今天，只要你报bug，他就会回复，通常也会修好。&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;cc-mode给Emacs提供C，C++，Java等一堆重要语言的支持，可以说是很多人每天都离不开的。和其他许多编辑器不一样，cc-mode用variable-name-face高亮的是变量或参数被声明，而不是被引用的地方，所以一眼就能轻松看出某个函数在哪里定义了哪几个局部变量。个人认为cc-mode的语法高亮是所有编辑器里最有用的，而不光是花花绿绿看着好看。&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;Emacs正是有这些默默无闻的大神一直在后面维护，才造就了Emacs无与伦比的编程体验。&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://www.emacswiki.org/emacs/AlanMackenzie&quot;&gt;EmacsWiki&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Henrik Lissner&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;doom-emacs&lt;/code&gt; 的作者，居于加拿大多伦多，追求简洁的设计风格，使&lt;code class=&quot;highlighter-rouge&quot;&gt;doom-emacs&lt;/code&gt;成为与&lt;code class=&quot;highlighter-rouge&quot;&gt;spacemacs&lt;/code&gt;齐名的项目。开发非常积极，态度友善，同时开发了不少配套项目，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;doom-themes&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;evil-multiedit&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;evil-snipe&lt;/code&gt;等。&lt;a href=&quot;https://github.com/seagle0128&quot;&gt;seagle0128&lt;/a&gt;的&lt;a href=&quot;https://github.com/seagle0128/doom-modeline&quot;&gt;doom-modeline&lt;/a&gt;也是在其启发和鼓励下开发的。&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://github.com/hlissner&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Matus Goljer&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;smartparens&lt;/code&gt;的作者，smartparens是流行的智能括号补全插件，类lisp编程的福音。同时开发和维护的流行插件包括&lt;code class=&quot;highlighter-rouge&quot;&gt;Elsa&lt;/code&gt;(Emacs Lisp Static Analyzer), &lt;code class=&quot;highlighter-rouge&quot;&gt;dired-hacks&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;clippy&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;litable&lt;/code&gt;等，都是功能强悍的精品。&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://github.com/Fuco1&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://fuco1.github.io/sitemap.html&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;Magnar Sveen&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;multiple-cursors&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;expand-region&lt;/code&gt;的作者，大大提升了编辑体验。如果你还没用过千万不要错过。同时开发和维护着非常流行的&lt;code class=&quot;highlighter-rouge&quot;&gt;elisp&lt;/code&gt;库&lt;code class=&quot;highlighter-rouge&quot;&gt;dash&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;.&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://github.com/magnars&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;http://twitter.com/magnars&quot;&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-name&quot;&gt;王勇&lt;/p&gt;

&lt;p class=&quot;hacker-summary&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Anything (Helm 前身)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Emacs Application Framework&lt;/code&gt;等众多 Emacs 插件的作者或重要贡献者，著名自由软件黑客，同时也是一个创业者（Deepin 前 CTO），人生经历非常丰富。&lt;a href=&quot;https://github.com/manateelazycat/manateelazycat.github.io/commit/a334c37a843571014b30364071d5f5f97331721b&quot;&gt;Commit by RenWenshan&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://github.com/manateelazycat&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://www.emacswiki.org/emacs/AndyStewart&quot;&gt;EmacsWiki&lt;/a&gt;&lt;/p&gt;

&lt;p class=&quot;hacker-link&quot;&gt;&lt;a href=&quot;https://manateelazycat.github.io&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">当你把Elisp完全学会并且可以写Emacs插件以后，你下一阶段的提升方法就是多向世界著名的Emacs黑客去学习，学习他们的代码细节，学习他们的思考方式和生活态度。</summary></entry><entry><title type="html">优化Emacs启动速度的方法论</title><link href="http://localhost:4000/emacs/2019/05/12/emacs-optimize-startup-speed.html" rel="alternate" type="text/html" title="优化Emacs启动速度的方法论" /><published>2019-05-12T00:00:00+08:00</published><updated>2019-05-12T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/05/12/emacs-optimize-startup-speed</id><content type="html" xml:base="http://localhost:4000/emacs/2019/05/12/emacs-optimize-startup-speed.html">&lt;h4 id=&quot;分析慢的原因&quot;&gt;分析慢的原因&lt;/h4&gt;
&lt;p&gt;首先下载 &lt;a href=&quot;https://github.com/dholm/benchmark-init-el&quot;&gt;benchmark-init&lt;/a&gt; 这个插件,
在配置最开始的位置写下配置：&lt;/p&gt;

&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;;; 加载的时候临时增大`gc-cons-threshold'以加速启动速度。&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;gc-cons-threshold&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;most-positive-fixnum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;;; 清空避免加载远程文件的时候分析文件。&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;file-name-handler-alist&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;'benchmark-init-modes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;'benchmark-init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;benchmark-init/activate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;;; 下面才写你的其它配置&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;启动完毕后，执行 M-x benchmark-init/show-durations-tree 命令，这个命令会递归的打印出所有插件的耗时明细。&lt;/p&gt;

&lt;h4 id=&quot;优化-动态加载插件&quot;&gt;优化： 动态加载插件&lt;/h4&gt;
&lt;p&gt;比如下面这个配置会禁止Emacs退出的时候问后台进程是否需要杀掉的问题，会用到 noflet 这个库。
一般你可以这样写：&lt;/p&gt;

&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;'noflet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;defadvice&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;save-buffers-kill-emacs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;around&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;no-query-kill-emacs&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;activate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;Prevent annoying \&quot;Active processes exist\&quot; query when you quit Emacs.&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;noflet&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;process-list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ad-do-it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样写的坏处是，Emacs没有退出时不会执行这个advice, 但是一启动就会加载 noflet 这个库, 浪费了启动时间。&lt;/p&gt;

&lt;p&gt;优化的方式如下，把要调用的库在用的时候再加载，改成这样就好很多：&lt;/p&gt;

&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;defadvice&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;save-buffers-kill-emacs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;around&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;no-query-kill-emacs&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;activate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;Prevent annoying \&quot;Active processes exist\&quot; query when you quit Emacs.&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;'noflet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;noflet&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;process-list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ad-do-it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;优化-按键触发加载&quot;&gt;优化： 按键触发加载&lt;/h3&gt;
&lt;p&gt;第二种优化方式主要用我头几天写的 &lt;a href=&quot;https://manateelazycat.github.io/emacs/2019/05/05/lazy-load.html&quot;&gt;lazy-load&lt;/a&gt; 技术来做。
把 90% 的插件放到运行时第一次按键时再加载，而不是启动的时候就加载好。
因为lazy-load那篇文章已经详细说明了用法，这里就不再复述。&lt;/p&gt;

&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;用我上面的三个优化步骤，可以把Emacs启动时间减少到 1/10.&lt;/p&gt;

&lt;p&gt;Enjoy! ;)&lt;/p&gt;</content><author><name></name></author><summary type="html">分析慢的原因 首先下载 benchmark-init 这个插件, 在配置最开始的位置写下配置：</summary></entry><entry><title type="html">读《重新理解创业》</title><link href="http://localhost:4000/reading/2019/05/07/reunderstanding-entrepreneurship.html" rel="alternate" type="text/html" title="读《重新理解创业》" /><published>2019-05-07T00:00:00+08:00</published><updated>2019-05-07T00:00:00+08:00</updated><id>http://localhost:4000/reading/2019/05/07/reunderstanding-entrepreneurship</id><content type="html" xml:base="http://localhost:4000/reading/2019/05/07/reunderstanding-entrepreneurship.html">&lt;p&gt;5.1的时候在家读了周航写的《重新理解创业》，这是一本我几乎读一页就需要标注半页的书。看到书中的很多文字，其实看到的更多是我自己，在深度奋斗的时候，自己犯过很多相同的错误。当时在这些错误中很难跳出局面来看待自己，这两年从操作系统行业出来以后，一直在复盘自己过去的成长和缺陷，内心做了很多真诚的对话，直到看了这本书，很多自我对话的内容才重新梳理清楚，才知道原来世界上不止有我犯过同样的错误，不止有我有同样的想法，好的是，当读完这本书时，我收获了更多释怀，更能接受过去的自己。&lt;/p&gt;

&lt;p&gt;周航是一个了不起的人，中国这种成王败寇的习惯给了太多成功者神话般的传说，周航却毫无保留的写出了自己创业过程中的无数坑，更难能可贵的是，当易道失败以后，认真的审视自我，进行了很多升维的思考，这种向内的深入审视带来的思考财富远远比创业成功后光鲜的表面结果更能激励创业者。&lt;/p&gt;

&lt;p&gt;读书有三遍，第一遍开拓视野，第二遍深入思考，第三遍写出感想至融入自我。&lt;/p&gt;

&lt;p&gt;下面就是我对这本书的第三遍阅读：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;和成功的待遇截然不同，这个社会又如此厌恶失败、鄙视失败。我们耻于谈论失败，甚至会讥讽一切失败的现象、失败的人。我们经常冷眼看着一家面临崩盘的公司走向灭亡，然后说：“我早就知道如此，你看，应验了吧？”眼见他起高楼，眼见他楼塌了，大家对待失败大抵都是这般吃瓜群众的心态。。。换个角度重新思考，从中你会发现美国创业文化中很重要的一部分是对失败的宽容。而且这种宽容，不仅没有影响到他们的创新，反而鼓励了创业者尝试和冒险，极大激发了创新。。。回溯科技史，我们发现推动行业发展的产品，并不全部都是成功的，失败在其中的作用举足轻重。正是那些失败的产品成为革新的养料——失败的尝试也是历史中群星闪耀的时刻。这样一看，所谓的失败是多么美好的事情，这是失败对于我们全社会的价值。如果一个社会还在耻于谈论失败、害怕失败、排斥失败，只崇尚成功的话，我们不太可能有探索意义上的创新。所以，如果你希望这是一个创新的国度，一个创新的社会，那么我们必然需要重新定义失败，重新理解失败。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以前做开源社区的时候，一直体会到国内开发者深入人心的 “国外的月亮圆，国外的代码就是香” 观念，当时一直从正面看，这是一种社会病态。但是现在想想，就和周航说的一样，背后深入的是整个社会害怕失败的教育和社会压力，大家因为太害怕失败以后给自己太多压力，从而导致自己没法从容的发挥和应对，往往最后真的就走向了失败。失败对于我这种性格好强的人，尤其有威慑力，为了做到完美，总是希望做到别人心目中的最好，即使身体有时候太累了，也在消耗式的坚持，往往容易进入High的时候像疯子，High完以后就进入 “对什么都不感兴趣” 的丧尸状态了。&lt;/p&gt;

&lt;p&gt;其实没有人能够每天都能够正能量，但是社会希望每天都是正能量，人性的本质本来就是残缺，但是人性的伟大也是因为残缺而不断努力的去修行，变成更好的自我的过程。如果每个人都是完美的，一个大家对统一完美的标准去活着，社会就会失去多样性，失去多样性的生态和社会最终都会磨灭。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们学习失败的真正目的在于，面对它，接受它，解决它，放下它，然后从中成长，让自己以后生活得更好。。。于是我总结，学习失败的真正意义在于，我们可以坦然面对失败、接受失败、解决失败、放下失败，而不是避免失败，因为任何人都避免不了。失败几乎就是生命的一部分。拒绝失败，就是拒绝生命本身。这也是失败对我个人的意义所在。。。企业的终极宿命跟人的生命一样，会经历出生、成长、青壮年的强壮、中年的瓶颈、衰老直至死亡，关键是你怎么看待这件事情。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以前，我都一直在遵循克服自己的缺点，努力的做更好的自己，不断学习不断成长。我对于失败，最多只是很快忘记失败，但是我从来没有像周航这样去诠释失败，去理解失败。&lt;/p&gt;

&lt;p&gt;一直很喜欢看神秘博士，神秘博士对于死亡是相当推崇的，认为死亡就是正常的一部分，也是生命精彩的延续。&lt;/p&gt;

&lt;p&gt;现在回想起来，客观的看我这前半生的所有事情，大多数都是失败的，总是先错很多次，最后一两次才会做对，跌跌撞撞的走过来，这么多事情，失败是常态，成功的事情在几率上寥寥无几。唯一的变化是，面对失败更从容。最开始写代码的时候，什么都不懂，一错了就怀疑自我，抱怨自我，但是写了十几年代码以后，发现现在再也不会因为代码写不出来而焦虑，因为理解和知识还没到那一步，没有看穿，所以不对，但是因为心中觉得总是可以解决的，所以现在很少会因为代码而焦虑，任何编程的知识对于我来说只是风格、体验和投入不一样，平常心，慢下来往往有更大的收获。&lt;/p&gt;

&lt;p&gt;我一直可以坦然面对失败，编程领域就是这样的。但是我在生活中，编程领域以外的区域，却很少能够像编程那样做的那么从容和快乐，撇开投入的时间和看穿的能力，最大的区别是，我对失败的认识不够。我在编程领域能够正确的认识失败，接受失败，但是在编程领域以外却很少能够面对失败，接受失败，导致有时候因为很多事情头破血流。&lt;/p&gt;

&lt;p&gt;现在体会到，不仅仅是编程，从编程扩展开去，人生和创业过程中，要做到面对失败、接受失败、解决失败、放下失败。原来一直让自己放下，但是自己总是放不下。现在看来，原来是不知道自己应该放下什么才导致自己越想放下越放不下。&lt;/p&gt;

&lt;p&gt;放下，放下失败才是修行！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你在创业的时候像当时的我们，把很多问题归结为营销问题，就要格外小心。实际上很可能是你在战略上出了问题，你的产品需求和定位就不应该那样设计。如果你需要用钓鱼的方式一个一个地“捞”用户，那说明这件事情本身就错了，你应该是用大网去捕鱼，而不是用鱼竿去钓鱼。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;技术人因为不善言辞，总是表面的认为自己不懂营销，往往机会陷入去学习很多营销的技巧上，这样从结果上往往还适得其反，纠其缘由还是战略方向不对。&lt;/p&gt;

&lt;p&gt;战略方向不对源于对事情没有看穿，对行业没有看穿，当自己能够看穿行业时，就能看到行业的未来和趋势，能够看到趋势时，营销和市场不过是看穿的表现形式，而不是通过营销本身的技巧去做到看穿和成功。&lt;/p&gt;

&lt;p&gt;所以，不管是市场营销高手还是技术人，本质上还是要多积累多思考，当你看穿这个行业时，营销就不会是问题，这个和一个人善不善于言辞关系这不大。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对一家公司，特别是创业公司来说，一个时期只能有一项关键任务，不能有多项。但是我看到太多创业公司同时在做多项内容，并发多进程任务，这说明还没有思考清楚本质问题。并发多进程任务，看起来给公司带来很多机会和可能性，但其实公司资源总共就这么点儿，在关键任务之外做其他事情都是浪费资源，所以我们要认清每个时期竞争的关键和本质。只有认识清楚，你才能够确定好一家公司在某个时期的关键任务是什么。关键任务清楚了，公司上下才能达成共识，把全公司之力放在这一件事上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;战略是自己视野和看穿行业的自然延伸，但是战略不是未来的口号和愿景。战略真正价值在于当你看穿一件事情以后，别人看不穿时，你可以通过你的战略去指导整个团队的执行力。而指导执行力的关键是，战略一定是简单的，单一的，专注并且带有长期价值的。&lt;/p&gt;

&lt;p&gt;简单来说，如果战略简单到一句话说清楚，公司所有人都能够说清楚，即是好的战略，如果最终还能够打胜仗，那就是伟大的战略。反之，复杂的，左右摇摆的，飘忽不定的都不是战略，今天打东边，明天打西边，最后只会让大家去怀疑战略的制定者是否真的想清楚了？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;愿景不是广告中的slogan（标语）。用户真的关心你的愿景吗？用户可能不会花时间理解它，因为他们最关心的是从中能得到什么。。。淘宝尚且如此，我们作为创业者更应该始终坚持挖掘品牌为用户创造的当下价值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以前就走过这样的坑，就像大多数互联网公司一样，不装逼说出一段传奇故事，不装逼写一段高逼格的文字感觉就不配做互联网公司，不配在这个牛逼的时代混下去。&lt;/p&gt;

&lt;p&gt;人都是自私的，社会也是自私的，但是整个社会在自私和多样性的生态中蓬勃发展，每个人都希望从别人那里获得更多的帮助和价值，同时自己创造价值去满足别人。&lt;/p&gt;

&lt;p&gt;从根本上来说，如果一个企业讲清楚自己做的事情能够对用户和对社会产生什么样的价值？别人就记住你了，这个比你未来是否能够登顶更能让大家记住，因为现在变化太快，未来是什么样的谁都不知道。&lt;/p&gt;

&lt;p&gt;当移动支付和打车在打价格战的时候，大家就知道一点，打车真便宜，座贼远的车还免费还倒给一瓶水，大家都说滴滴好，但是真的布局完成，价格战回归理性后，司机越来越少，大家只会抱怨滴滴。你说滴滴变了吗？也许一开始就那么坏，也许没有大家想的那么坏，但是为什么短短几年，大众的意识形态变化那么多？因为人只关心可以从你这里获得什么， 大部分人都倾向于看短期利益。所以赚钱来说，就是要把当下的价值说清楚，就是最好的品牌宣传，当在很长时间区间里把每个阶段和每个当下都做好了，愿景自然就实现了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;因此，判断一个产品的流量是否有价值，我们先看以下几个要素：一是用户数，即DAU；二是时长，看用户黏性；三是交易属性。后来我自己有一个用来判断的公式：流量价值=DAU×时长×交易系数。。。比如宜家，为什么它要卖1元的冰激凌？很明显这并不赚钱，但宜家却非常欢迎大家去占这个便宜。因为家具是个低频、高价的产品，所以宜家需要在家具之外卖家居，比如衣服架、毛巾架、拖鞋以及那些价格非常低的食物等，这些家居产品的消费频次肯定要高得多。通过高频、低价的商品拉来流量，也为其他方面带来了利润，很多聪明的商家都会采用这个策略。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以前大家都在谈流量，但是流量是什么？流量怎么来？大家只看到别人有流量自己羡慕？但是自己做不到，做不到的原因是什么？还是看不穿。&lt;/p&gt;

&lt;p&gt;流量的定义：DAU x 时长 x 交易系数&lt;/p&gt;

&lt;p&gt;以前很不能理解那些不赚钱的商品，但是从这个公式来看，低利润和高利润的商品都有它自身的价值和战术战略一样，多样性和复杂性才是对抗不确定未来的最好的策略，而不仅仅只是看利润高的单一策略。&lt;/p&gt;

&lt;p&gt;同时知道流量的价值后，倒过来很多事情怎么做选择反倒更为简单了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.勇敢地做自己。2.去搭建你真正喜欢的团队，因为你只能领导你喜欢的人。3.去做与你的特质和领导力相匹配的事情。我相信你的领导力一定会得到充分发挥，你也将成为一个有领导力的人。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以前有很长一段时间都在锻炼自己包容不同性格的人，甚至专门找那种和我不一样的人去相处。客观的说，锻炼了自己很多，但是同时也让自己更多的失去自我，变的越来越活的像大家期望的样子，反而失去了自我最宝贵的特质，当人失去自我的时候，往往也就是失去一切的开端。&lt;/p&gt;

&lt;p&gt;看到周航这一个观点的时候，还是蛮感慨的，人活一辈子的轨迹也是蛮有趣的，从向别人学习，包容别人到回归自己。&lt;/p&gt;

&lt;p&gt;现在特别能够理解这段话，因为你只能领导你喜欢的人，哈哈哈，有时候和三观不和的人一起合作，其实往往事倍功半，当然这句话不是说不包容和固执，而是先要修行好自己，臭味相投但同时一样厉害的人一起合作，那种默契的感觉会好到你忘记人生和创业的痛苦。&lt;/p&gt;

&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;

&lt;p&gt;总是喜欢去找一段最喜欢的话作为文章的结尾，希望同样可以激励正在阵痛期而未来更勇敢的你。&lt;/p&gt;

&lt;p class=&quot;line-quote&quot;&gt;这段时间我有特别大的感触，总结一个关键词就是“成败”。我想说，只有你足够痛的时候，新的光亮才可能照进来。痛可能是光照进来的地方，如果你有足够的痛，恭喜你，你可能有新的开始，因为新的光亮可能照到你。在易到的创业中我经历了各种各样的事情，直到今年还遇到一些很痛苦的事情。正是因为经历太多，这些痛在自己心中反复咀嚼，才使得我开始把眼光真正从外部收回，从向外看世界回到了向内看自己，看自己的内心是怎么想的，认知上有没有变化，又应该有什么变化。我觉得只有足够痛的时候才会有这种心态，才会有新的开始。&lt;/p&gt;</content><author><name></name></author><summary type="html">5.1的时候在家读了周航写的《重新理解创业》，这是一本我几乎读一页就需要标注半页的书。看到书中的很多文字，其实看到的更多是我自己，在深度奋斗的时候，自己犯过很多相同的错误。当时在这些错误中很难跳出局面来看待自己，这两年从操作系统行业出来以后，一直在复盘自己过去的成长和缺陷，内心做了很多真诚的对话，直到看了这本书，很多自我对话的内容才重新梳理清楚，才知道原来世界上不止有我犯过同样的错误，不止有我有同样的想法，好的是，当读完这本书时，我收获了更多释怀，更能接受过去的自己。</summary></entry><entry><title type="html">利用lazy-load.el按需加载Emacs插件</title><link href="http://localhost:4000/emacs/2019/05/05/lazy-load.html" rel="alternate" type="text/html" title="利用lazy-load.el按需加载Emacs插件" /><published>2019-05-05T00:00:00+08:00</published><updated>2019-05-05T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/05/05/lazy-load</id><content type="html" xml:base="http://localhost:4000/emacs/2019/05/05/lazy-load.html">&lt;p&gt;随着Emacs的插件越来越多，Emacs的启动速度会越来越幔。&lt;/p&gt;

&lt;p&gt;Emacs的启动速度慢，主要有两个原因：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;加载时垃圾回收的阈值太小了，导致启动加载插件时触发了垃圾回收，减慢了启动速度&lt;/li&gt;
  &lt;li&gt;默认Emacs加载了过多的插件，导致启动的时候浪费了过多的时间去加载插件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;解决第一个问题的方法如下：&lt;/p&gt;
&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;; 加载的时候临时增大`gc-cons-threshold'以加速启动速度。&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;gc-cons-threshold&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;most-positive-fixnum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;;; 清空避免加载远程文件的时候分析文件。&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;file-name-handler-alist&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;;; Emacs配置文件内容写到下面.&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的代码的目的时，在Emacs加载任何插件之前临时把 gc-cons-threshold 的值设置为最大，避免Emacs启动时触发垃圾回收。
Emacs配置文件加载完毕后，自动恢复变量 gc-cons-threshold 为默认值，避免运行时Emacs占用过多内存。&lt;/p&gt;

&lt;p&gt;至于第二个问题的解决方案，就要用到今天我编写的 lazy-load.el 插件了。&lt;/p&gt;

&lt;p&gt;2007 ~ 2008这两年期间，我几乎把当时所有的Emacs插件都玩过一遍，当你把几百个插件一股脑的全部默认加载，Emacs的启动时间可以从秒开延长到几分钟。
那时候就在思考怎么把Emacs的启动时间优化到秒开，同时不减少任何插件的使用，最终开发了 lazy-load.el 插件，即使我用 300+ 插件，Emacs启动速度依然是秒开。&lt;/p&gt;

&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;

&lt;p&gt;lazy-load.el 的原理很简单:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;我们先把我们的 keymap 定义好,每个按键对应的函数都写好&lt;/li&gt;
  &lt;li&gt;告诉Emacs函数对应插件的文件名，这样当调用函数时，Emacs知道去哪里加载插件&lt;/li&gt;
  &lt;li&gt;Emacs默认只加载非常少的插件, 加载完成后，当我们第一次触发按键时才让Emacs去动态按需加载插件和按键对应的函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为99%的Emacs插件在单独加载的时候，都可以在1s之内完成，所以相当于99%的插件都在运行时按需加载，
这样就大大减少了Emacs启动时需要加载的插件数量，从而最终达到提升Emacs启动时间的目的。&lt;/p&gt;

&lt;h3 id=&quot;安装方法&quot;&gt;安装方法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;下载 &lt;a href=&quot;https://github.com/manateelazycat/lazy-load&quot;&gt;lazy-load&lt;/a&gt; 里面的 lazy-load.el 放到 ~/elisp 目录&lt;/li&gt;
  &lt;li&gt;把下面的配置加入到 ~/.emacs 中&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(add-to-list 'load-path (expand-file-name &quot;~/elisp&quot;))
(require 'lazy-load)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;
&lt;p&gt;下面这段代码的意思是，第一次按 Alt + g 时，Emacs在 load-path 目录下去找　goto-line-preview.el 这个文件，加载插件并执行 goto-line-preview 这个函数。&lt;/p&gt;

&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lazy-load-global-keys&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;M-g&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;goto-line-preview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;&quot;goto-line-preview&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面这段代码的意思是，第一次按在 ruby mode 中按 Ctrl + c t 时，Emacs在 load-path 目录下去找　ruby-extension.el 这个文件，加载插件并执行 ruby-hash-syntax-toggle 这个函数。&lt;/p&gt;

&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lazy-load-local-keys&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;C-c t&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ruby-hash-syntax-toggle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
 &lt;span class=&quot;nv&quot;&gt;ruby-mode-map&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;&quot;ruby-extension&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;很多全局按键默认已经被Emacs占用了，必须先卸载以后才能重新绑定这些全局按键，比如 Ctrl + x, 下面这段代码就是用 lazy-load-unset-keys 卸载默认绑定的全局按键：&lt;/p&gt;

&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lazy-load-unset-keys&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;C-x C-f&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C-z&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C-q&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;s-W&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;s-z&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;M-h&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C-x C-c&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C-\\&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;s-c&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;s-x&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;s-v&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;高级用法&quot;&gt;高级用法&lt;/h3&gt;
&lt;p&gt;有时候，我们会用一个前缀按键取分类插件中不同的函数，比如我的 sdcv.el 插件的不同函数就可以按照下面的代码用 Ctrl + z 这个按键作为前缀按键，
先按 Ctrl + z ，再按 p 就可以触发 sdcv-search-pointer 函数&lt;/p&gt;

&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lazy-load-global-keys&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;p&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;sdcv-search-pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;y&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;sdcv-search-pointer+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;i&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;sdcv-search-input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;sdcv-search-input+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;&quot;init-sdcv&quot;&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;&quot;C-z&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应的 lazy-load-local-keys 也支持最后一个参数传递前缀按键，只不过 lazy-load-local-keys 对应的不是 global-map ，而是插件的 keymap 。&lt;/p&gt;

&lt;p&gt;如果Emacs默认就加载了某个插件，而不需要在运行时动态加载，也可以使用 lazy-load-set-keys 函数做单独的按键绑定操作，不用手动写一行行的重复写类似　(define-key keymap key) 的配置&lt;/p&gt;

&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lazy-load-set-keys&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;M-;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;comment-dwim-with-haskell-style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
 &lt;span class=&quot;nv&quot;&gt;haskell-mode-map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/manateelazycat/lazycat-emacs/blob/master/site-lisp/config/init-key.el&quot;&gt;这里有很多 lazy-load 的示例用法&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">随着Emacs的插件越来越多，Emacs的启动速度会越来越幔。</summary></entry></feed>