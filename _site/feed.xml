<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-07-19T11:54:38+08:00</updated><id>http://localhost:4000/feed.xml</id><entry><title type="html">禁止TabNine不停的催我升级收费版本</title><link href="http://localhost:4000/emacs/2019/07/19/silent-tabnine.html" rel="alternate" type="text/html" title="禁止TabNine不停的催我升级收费版本" /><published>2019-07-19T00:00:00+08:00</published><updated>2019-07-19T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/07/19/silent-tabnine</id><content type="html" xml:base="http://localhost:4000/emacs/2019/07/19/silent-tabnine.html">&lt;p&gt;前天推荐了非常好用的&lt;a href=&quot;https://manateelazycat.github.io/emacs/2019/07/17/tabnine.html&quot;&gt;TabNine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这几天用下来，越用越喜欢，而且觉得免费版就够了, 但是TabNine在大型项目（超过400kb索引）的时候，会一直在 echo-area 催我升级收费版本，有点烦人。&lt;/p&gt;

&lt;p&gt;研究了一下 company 的源代码，写了一段补丁，把下面的代码粘贴到 ~/.emacs 配置文件中， TabNine就不会在大项目中反复的提示你升级收费版本了：&lt;/p&gt;

&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;;; The free version of TabNine is good enough,&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;;; and below code is recommended that TabNine not always&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;;; prompt me to purchase a paid version in a large project.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;defadvice&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;company-echo-show&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;around&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;disable-tabnine-upgrade-message&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;activate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;company-message-func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ad-get-arg&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;company-message-func&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;stringp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;funcall&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;company-message-func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;string-match&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;The free version of TabNine only indexes up to&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;funcall&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;company-message-func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;ad-do-it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;世界终于清静了，但是鉴于TabNine补全的爽快，还是建议大家多多去&lt;a href=&quot;https://tabnine.com/buy&quot;&gt;购买&lt;/a&gt;TabNine的收费版本, 支持一下作者。&lt;/p&gt;</content><author><name></name></author><summary type="html">前天推荐了非常好用的TabNine</summary></entry><entry><title type="html">TabNine 利用机器学习技术来补全项目代码</title><link href="http://localhost:4000/emacs/2019/07/17/tabnine.html" rel="alternate" type="text/html" title="TabNine 利用机器学习技术来补全项目代码" /><published>2019-07-17T00:00:00+08:00</published><updated>2019-07-17T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/07/17/tabnine</id><content type="html" xml:base="http://localhost:4000/emacs/2019/07/17/tabnine.html">&lt;p&gt;我好久没有推荐过一款Emacs插件了，感觉大部分的Emacs插件只是设计的非常贴心，但是真的让我惊讶的Emacs插件真的很少了。&lt;/p&gt;

&lt;p&gt;今天就来推荐一个让我惊讶的技术：TabNine&lt;/p&gt;

&lt;p&gt;网上对 TabNine 的评价:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TabNine是一种基于OpenAI的语言模型（GPT-2）来实现的智能代码补全技术。
它支持23种编程语言、5种编辑器，使用简单，效果惊艳。
不少使用过的网友说：TabNine是他们用过的最好的代码补全工具，这是属于程序员的杀手级应用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我记得最开始看到TabNine的时候是一个多月前，当时以为只是无脑AI新闻，并没有太认真去看待它，认为不过是一个噱头。但是从我短时间的体验来看，我改变了看法。&lt;/p&gt;

&lt;h3 id=&quot;我对tabnine的评价&quot;&gt;我对TabNine的评价&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TabNine通过很复杂的技术来学习当前项目的源代码，
通过研究程序员的编码习惯最终来预测接下来可能会键入的单词或长句。

传统的代码补全主要是基于当前文件的抽象语法树来进行上下文语义分析，
现在做的最好的技术就是LSP协议，这些传统的语法补全技术在补全对象的属性或者方法的时候很好用。

但是TabNine完全基于一种更为开放的分析方式来实现代码补全，
在它分析现有项目的源代码后，不管是补全模板、方法变量还是代码片段，
TabNine会根据它自己的算法来进行智能排序, 给出它认为最佳的匹配结果。

打个比方，TabNine在光标处线索不够的时候，它有点像个精神病人那样喃喃自语，
但是一旦它预测准确以后，它可以补全非常一长串代码，
这段代码虽然不是属性和方法名，但是一旦准确预测，
你可以敲一下Tab键就完成当前行的代码编写。
而且这种技术在越大的项目中，代码预测补全效果越好。

整体的感觉，就像一个懂你的机器人在帮你找你自己的代码思想和代码片段，
在必要的时候帮你敲很长很长的代码。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;说的很玄乎，举两个例子：&lt;/p&gt;

&lt;h4 id=&quot;elisp代码补全&quot;&gt;Elisp代码补全&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/tabnine/elisp.png&quot; alt=&quot;Elisp exampele&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面是我写的Emacs插件aweshell.el，当我敲击 &lt;code class=&quot;highlighter-rouge&quot;&gt;current-window&lt;/code&gt; 的时候，TabNine 的补全建议是：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;current-window (selected-window)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;current-window (selected-window)&lt;/code&gt; 不是一个正常的语法补全结构，
但是当我敲 &lt;code class=&quot;highlighter-rouge&quot;&gt;current-window&lt;/code&gt; 这段代码的时候，脑袋里就是希望通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;(selected-window)&lt;/code&gt; 方法赋值结果给变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;current-window&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;TabNine 在这个时候就让你很爽了，不管他的算法是怎么做的，这就是你想要的片段，Tab一下子就补全了。&lt;/p&gt;

&lt;h4 id=&quot;javascript代码补全&quot;&gt;JavaScript代码补全&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/tabnine/js.png&quot; alt=&quot;JavaScript exampele&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面是一段JavaScript的项目代码，其中有一段 &lt;code class=&quot;highlighter-rouge&quot;&gt;machineDict[res.data[i].MachineId] = res.data[i].Name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;很多时候，我们会通过编写库和函数的方式来抽象重复代码，但是真实的项目中，对于一些使用一两次的代码片段，往往没有必要写函数去过度包装。&lt;/p&gt;

&lt;p&gt;所以当我在另外一个函数中写下 &lt;code class=&quot;highlighter-rouge&quot;&gt;machineDict[res.data[i].MachineId] = res.data[i]&lt;/code&gt; 然后敲击 . 的时候，TabNine 通过算法分析出，我很有可能是想写 &lt;code class=&quot;highlighter-rouge&quot;&gt;res.data[i].Name&lt;/code&gt; ， 那也正是我想要的。&lt;/p&gt;

&lt;p&gt;注意这个例子中， Name 仅仅只是服务器返回的JSON结构体的一个属性值，从传统的抽象语法树补全技术看，&lt;code class=&quot;highlighter-rouge&quot;&gt;res.data[i]&lt;/code&gt; 仅仅就是临时变量，除非真实从服务器请求，否则基于属性和方法的技术来解析，根本就不知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;res.data[i]&lt;/code&gt; 是什么类型的对象，更不用说代码补全了。&lt;/p&gt;

&lt;p&gt;而TabNine的技术就是对传统语法补全技术的一种极好的补充，因为程序员每天大部分时间都是在重复自己以前的编程思想和代码片段，为什么不让机器来辅助人从重复的代码拷贝中解脱出来呢？&lt;/p&gt;

&lt;h3 id=&quot;tabnine-emacs补全前端&quot;&gt;TabNine Emacs补全前端&lt;/h3&gt;
&lt;p&gt;TabNine的Emacs插件在 &lt;a href=&quot;https://github.com/TommyX12/company-tabnine&quot;&gt;company-tabnine&lt;/a&gt; , 里面有详细的安装方法。&lt;/p&gt;

&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;从整体上看TabNine就是找各种token来暴力学习，所以性能的表现上比很多LSP服务器还要好，我在Emacs中使用TabNine补全，非常顺滑。&lt;/p&gt;

&lt;p&gt;我希望有一天这种技术可以直接感知我的思想，这样我就不用动手了， 想一想代码就自动写完了，哈哈哈。&lt;/p&gt;</content><author><name></name></author><summary type="html">我好久没有推荐过一款Emacs插件了，感觉大部分的Emacs插件只是设计的非常贴心，但是真的让我惊讶的Emacs插件真的很少了。</summary></entry><entry><title type="html">Vue.js的实践小技巧</title><link href="http://localhost:4000/web/2019/07/14/vue-tooltips.html" rel="alternate" type="text/html" title="Vue.js的实践小技巧" /><published>2019-07-14T00:00:00+08:00</published><updated>2019-07-14T00:00:00+08:00</updated><id>http://localhost:4000/web/2019/07/14/vue-tooltips</id><content type="html" xml:base="http://localhost:4000/web/2019/07/14/vue-tooltips.html">&lt;h3 id=&quot;vuejs是计算机发展的趋势使然&quot;&gt;Vue.js是计算机发展的趋势使然&lt;/h3&gt;
&lt;p&gt;计算机的历史总是遵循分久必合合久必分的趋势，最开始Web前端硬件和浏览器的性能不够，为了用户体验和性能，开发者会选择像 Rails 类似的框架 来进行服务端模板渲染以提升性能，但是服务端模板渲染的技术弊端是，当前端界面复杂度达到PC软件的规模时，界面的调整太依赖于后端和DOM结构树的查询节点树，一旦要更新页面布局和设计时就需要后端改动一下，前端也改动一下，一旦前端界面大改时，JQuery这种依赖模板和DOM查询节点的方法就会很被动，因为界面布局和结构发生巨变时，DOM节点查询链条很容易断裂，代码也不敢轻易变动和删除，导致项目越久，代码冗余越多，项目也变得很难维护。&lt;/p&gt;

&lt;p&gt;Vue.js 主要解决的问题是，整个前端的界面修改都是在浏览器中完成的, 服务端只用提供API即可，而且界面整体逻辑是通过属性来动态绑定的，界面布局调整的JS代码并不依赖于DOM的节点查询，如果需要修改界面布局和设计时，只用大胆的调整前端模板和CSS样式即可，JS逻辑和后端代码都不用配合修改，整个界面改动的负担很小，可维护性也非常好。&lt;/p&gt;

&lt;p&gt;原来学Rails的时候，对Vue.js和React的技术抱有偏见，很多Web的开发者总是争论到底是后端服务渲染好，还是Vue.js这种前端框架好？在我看来，任何撇开时代背景和用户需求的技术讨论都是个人喜好性质的讨论。&lt;/p&gt;

&lt;p&gt;从总体来说，用户肯定希望界面交互越复杂越精致越好，不论后端渲染还是Vue.js这种前端框架，从理论上都是可以满足用户的计算需求的，只是Vue.js这种前端框架把真实的计算逻辑和界面布局给完全分开了，当快速迭代产品设计和交互体验时，Vue.js的更新和维护负担更小，成本更低的改动就意味着生产力和竞争力。&lt;/p&gt;

&lt;p&gt;所以Vue.js这种前端框架的大行其道，并不是技术框架在技术层面的谁优谁劣，而是Web终端硬件性能提升和用户对Web应用功能期待的一种自然而然的演化行为，虽然Vue.js/React这种技术有很多技术细节和优点，但是从架构设计上来看，其实当今的Web技术又回到微软时代的那种前后端分离的技术，架构上是没有区别的，只是Vue.js相对于MFC、Gtk这类的技术，通过属性绑定和动态DOM的技术能够更有生产力的编写前端界面。&lt;/p&gt;

&lt;h3 id=&quot;vuejs-的优点&quot;&gt;Vue.js 的优点&lt;/h3&gt;
&lt;p&gt;对于我这种非常熟悉Gtk/Qt的开发者来说，我更喜欢Vue.js这种前后端分离的设计，因为前端的修改非常有效率，实时可以看到最新的界面效果，同时后端也可以做的很薄，后端从模板构造和服务的泥潭中解放出来，后端可以更专注于后端架构设计、工程化运维和性能优化。&lt;/p&gt;

&lt;p&gt;Vue.js 的优点主要有以下几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过属性绑定和DOM Tree Diff更新的技术来实时渲染Web界面，前端开发生产力非常高&lt;/li&gt;
  &lt;li&gt;Vue.js的作者是国人，中文文档写的非常好，我想这也是Vue.js在中国非常流行的原因，官方的文档看一天即可入门&lt;/li&gt;
  &lt;li&gt;内置 VueRouter、Vuex全家桶，包括 vue-cli 的发布，真正做到开箱即用，不用折腾各种插件和让人绝望的Webpack配置即可快速把精力投入到产品开中&lt;/li&gt;
  &lt;li&gt;*.vue 文件一体化的设计，模板、JS代码和CSS样式，一个组件一个文件，非常好维护&lt;/li&gt;
  &lt;li&gt;插件生态非常好，常用的各种插件都有Vue的版本，npm或者yarn都可以快速实验插件功能&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;vuejs-的一些小技巧&quot;&gt;Vue.js 的一些小技巧&lt;/h3&gt;
&lt;p&gt;虽然Vue.js的&lt;a href=&quot;https://cn.vuejs.org/index.html&quot;&gt;官方文档&lt;/a&gt;写的非常好，但是通过几个项目的实践，还是有一些隐晦的地方需要自己动手才能搞懂。&lt;/p&gt;

&lt;h4 id=&quot;vuejs路由的支持&quot;&gt;Vue.js路由的支持&lt;/h4&gt;
&lt;p&gt;Vue.js官方文档可能从入门的角度看，都是用单文件的方式来展示Vue.js的示例，但是真实的项目往往都是需要前端路由来控制，即使看完Vue.js/Vuex的文档，我相信大多数人还是不知道怎么修改一个 vue-cli 项目去支持前端页面的路由跳转。&lt;/p&gt;

&lt;h4 id=&quot;路由跳转之appvue&quot;&gt;路由跳转之App.vue&lt;/h4&gt;
&lt;p&gt;首先 App.vue 文件要改成 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;&lt;/code&gt; 的形式，这样所有Vue.js动态切换的页面都会在 router-view 中进行替换，下面是我的 App.vue, 这个文件除了调样式外基本不用作任何改动。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;router&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/router-view&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/template&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;components&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/style&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;路由跳转之mainjs&quot;&gt;路由跳转之main.js&lt;/h4&gt;
&lt;p&gt;其次 main.js 要修改成下面的样子，这样你只用在 components 目录添加新的组件，然后更新 VueRouter 的内容即可实现各种路由跳转。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;router.beforeEach&lt;/code&gt; 这一段代码的意思是，路由更新是更改浏览器标签的标题。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Vue&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;vue&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;VueRouter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;vue-router&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./App.vue&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Login&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./components/Login.vue&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Home&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./components/Home.vue&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Vue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;productionTip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Vue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;VueRouter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;router&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;VueRouter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;routes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Login&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Login title&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/home&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Home&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Home title&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;router&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;beforeEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;title&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Vue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;#app&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;router&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;router&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;vuejs-组件中属性关键字&quot;&gt;Vue.js 组件中属性关键字&lt;/h3&gt;

&lt;p&gt;*.Vue组件文件中一般分为几个不同的代码区域：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;data() { … }&lt;/li&gt;
  &lt;li&gt;props: { … }&lt;/li&gt;
  &lt;li&gt;computed: { … }&lt;/li&gt;
  &lt;li&gt;watch: { … }&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;初学者一般看到这几个关键字都是一脸懵逼的，其实 Vue.js 是对组件不同属性的用法，分别用不同的关键字进行区分的。&lt;/p&gt;

&lt;h4 id=&quot;data---&quot;&gt;data() { … }&lt;/h4&gt;

&lt;p&gt;data代码区域是组件内部自己用的，可以看做组件内部属性初始值的声明区域, 一般都是下面的形式:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;attr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;attr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;attr3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&quot;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;props---&quot;&gt;props: { … }&lt;/h4&gt;
&lt;p&gt;props代码区域是专门用于父组件进行属性绑定的，比如Foo组件是一个画布，就可以声明&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Number&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样在其他组件Bar调用Foo时，就可以在模板中写入:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;Foo&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;:width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;600&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;:height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;400&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然上面的 width 和 height 也可以换成 Foo 组件内部的属性值，只要父组件 Bar 属性发生变化，Foo组件的 width 和 height 属性也一起关联更新。&lt;/p&gt;

&lt;p&gt;所以 props 区域的状态可以看成当前组件和其父组件之间属性绑定和通信的一种方式。&lt;/p&gt;

&lt;h4 id=&quot;computed---&quot;&gt;computed: { … }&lt;/h4&gt;
&lt;p&gt;computed代码区域是用作组件内部属性和Vuex Store状态绑定的，比如 Vuex 有一个 count 的状态，可以通过以下部分来声明组件内部的 count 属性, 一旦 Store 的 count 发生变化，组件内部的 count 属性也会跟着一起变化。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;computed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;watch---&quot;&gt;watch: { … }&lt;/h4&gt;
&lt;p&gt;watch代码区域是专门用户监听 Store 状态变化的，一旦 Store 状态发生变化，就可以在 watch 代码区域中调用对应的组件函数, 比如&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Vue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;#demo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;lastName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Bar&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;fullName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Foo Bar&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;watch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fullName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lastName&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;lastName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fullName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;firstName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当 Store 的 firstName 发生变化时，就可以更新组件内部的 fullName 属性。&lt;/p&gt;

&lt;h3 id=&quot;属性键字区分总结&quot;&gt;属性键字区分总结&lt;/h3&gt;
&lt;p&gt;看懂上面的说明后，按照以下方式记忆，然后多实践就可以很清晰明了了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;data() { … } – 组件内部属性&lt;/li&gt;
  &lt;li&gt;props: { … } – 需要和父组件通信的属性&lt;/li&gt;
  &lt;li&gt;computed: { … } – 和Store状态绑定的属性&lt;/li&gt;
  &lt;li&gt;watch: { … } – 监听Store状态变化的回调区域&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;store子模块&quot;&gt;Store子模块&lt;/h3&gt;
&lt;p&gt;当项目很复杂时，需要针对不同用途的 Store 进行单文件管理，而不是所有状态都放在 store/index.js 里面。&lt;/p&gt;

&lt;p&gt;比如有一个单独的状态模块 store/modules/Backround.js :&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;zoomRatio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getters&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;zoomRatio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;zoomRatio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mutations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;updateZoomRatio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ratio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;zoomRatio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ratio&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;namespaced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;getters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;mutations&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 *.Vue 组件中，动态绑定 Store 的 zoomRatio 状态，就需要这样写 computed 声明:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;computed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;nl&quot;&gt;zoomRatio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;kd&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Background/zoomRatio&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
         &lt;span class=&quot;kd&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Background/updateZoomRatio&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为 Background.js 是 store/modules 子目录下声明的单独Store模块&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先需要在 Background.js 模块中增加 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespaced: true&lt;/code&gt; 的关键字以支持命名空间&lt;/li&gt;
  &lt;li&gt;其次需要在组件中用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Background/zoomRatio&lt;/code&gt; 的前缀去调用 Store 状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样才能在组件中对Store子模块的状态进行正常访问&lt;/p&gt;

&lt;h3 id=&quot;eventbus-回调调用两次的问题&quot;&gt;EventBus 回调调用两次的问题&lt;/h3&gt;
&lt;p&gt;对于组件之间的单向通讯，比如子组件发送信号给父组件，有时候用 EventBus 更轻便。&lt;/p&gt;

&lt;p&gt;一般我们都会在 mounted 区域中通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;EventBus.$on(&quot;signal&quot;, this.callback)&lt;/code&gt; 的方式进行事件回调处理:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;mounted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;EventBus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个地方的坑在于，一旦页面切换时，页面加载一次就会调用一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;EventBus.$on(&quot;signal&quot;, this.callback)&lt;/code&gt; , 页面加载多次就会导致调用多次事件回调，在项目实践中会产生各种诡异的现场。&lt;/p&gt;

&lt;p&gt;要保证页面加载的时候只调用一次事件回调，就需要在 beforeDestroy 区域中调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;EventBus.$off(&quot;signal&quot;)&lt;/code&gt; 方法:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;beforeDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;EventBus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码的意思是，当页面销毁时注销事件回调，当页面创建时再注册事件回调，这样就解决 EventBus 回调调用两次的诡异问题。&lt;/p&gt;

&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;虽然上面写了这么多，但是从整体上看，一旦你熟悉了Vue.js的使用方式，Vue.js已经算同等规模开源项目里面坑比较少的项目，用起来还是非常省心和好用的。&lt;/p&gt;

&lt;p&gt;上面就是我在Vue.js项目实践中的一些技巧分享，希望看到此文章的同学少走一些弯路。&lt;/p&gt;</content><author><name></name></author><summary type="html">Vue.js是计算机发展的趋势使然 计算机的历史总是遵循分久必合合久必分的趋势，最开始Web前端硬件和浏览器的性能不够，为了用户体验和性能，开发者会选择像 Rails 类似的框架 来进行服务端模板渲染以提升性能，但是服务端模板渲染的技术弊端是，当前端界面复杂度达到PC软件的规模时，界面的调整太依赖于后端和DOM结构树的查询节点树，一旦要更新页面布局和设计时就需要后端改动一下，前端也改动一下，一旦前端界面大改时，JQuery这种依赖模板和DOM查询节点的方法就会很被动，因为界面布局和结构发生巨变时，DOM节点查询链条很容易断裂，代码也不敢轻易变动和删除，导致项目越久，代码冗余越多，项目也变得很难维护。</summary></entry><entry><title type="html">Jekyll实时刷新</title><link href="http://localhost:4000/tech/2019/07/14/jekyll-livereload.html" rel="alternate" type="text/html" title="Jekyll实时刷新" /><published>2019-07-14T00:00:00+08:00</published><updated>2019-07-14T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/07/14/jekyll-livereload</id><content type="html" xml:base="http://localhost:4000/tech/2019/07/14/jekyll-livereload.html">&lt;p&gt;用Jekyll写博客时，总是写一写的需要手动刷新一下浏览器看效果，今天看了一下Jekyll的官方文档&lt;/p&gt;

&lt;p&gt;用下面的命令启动Jekyll服务器, 而不是命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;，博客内容修改完成以后浏览器就可以实时自动刷新。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll serve &lt;span class=&quot;nt&quot;&gt;--livereload&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置好实时刷新功能以后，博客的编写预览更加无缝衔接了，以下是我平常写博客的工作流:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;在Emacs中用 markdown-mode 写博客&lt;/li&gt;
  &lt;li&gt;手指头一松开，&lt;a href=&quot;https://github.com/manateelazycat/auto-save&quot;&gt;auto-save&lt;/a&gt; 插件会自动保存文件内容&lt;/li&gt;
  &lt;li&gt;用 Hammerspoon 切换到浏览器，浏览器的内容已经自动刷新&lt;/li&gt;
  &lt;li&gt;完成后用 Magit 快捷键，同步文章到 Github&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">用Jekyll写博客时，总是写一写的需要手动刷新一下浏览器看效果，今天看了一下Jekyll的官方文档</summary></entry><entry><title type="html">怎么徒手修复MacBook键盘？</title><link href="http://localhost:4000/mac/tech/2019/07/09/fix-macbook-keyboard.html" rel="alternate" type="text/html" title="怎么徒手修复MacBook键盘？" /><published>2019-07-09T00:00:00+08:00</published><updated>2019-07-09T00:00:00+08:00</updated><id>http://localhost:4000/mac/tech/2019/07/09/fix-macbook-keyboard</id><content type="html" xml:base="http://localhost:4000/mac/tech/2019/07/09/fix-macbook-keyboard.html">&lt;p&gt;继上个星期我把&lt;a href=&quot;https://manateelazycat.github.io/mac/tech/2019/07/04/fuck-mackbook-keyboard.html&quot;&gt;MacBook Pro的键盘敲碎了&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我在淘宝上买了键帽准备开始修复&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fix-macbook-keyboard/1.jpeg&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;谁知是一场从头到尾的作死，也最终产生了这篇怎么教你徒手修复键盘的攻略&lt;/p&gt;

&lt;h3 id=&quot;从头到尾的作死&quot;&gt;从头到尾的作死&lt;/h3&gt;
&lt;p&gt;最开始，我以为只是键帽坏了，把键帽暴力按上去以后我才发现，其实本质上是蝴蝶支架坏了。
当时也不知道我是怎么想的，去了五金店买了一瓶502胶水用来粘支架，当502滴下去那一瞬间，胶水瞬间晕染开来，
不但把支架粘住了，同时也把键帽的底座整个给粘住了，因为502是速干腐蚀性胶水，在粘住支架的同时也把底座的塑料给腐蚀了。&lt;/p&gt;

&lt;p&gt;MacBook Pro的蝴蝶键盘的回弹除了支架以外，主要靠底座的触点铁片和铁片之上的弹性塑料，当弹性塑料被502脆化以后，
整个按键都无法回弹了。&lt;/p&gt;

&lt;p&gt;看着完全无法回弹的J键，我知道502是这次作死操作的罪魁祸首。&lt;/p&gt;

&lt;h3 id=&quot;分析原因&quot;&gt;分析原因&lt;/h3&gt;
&lt;p&gt;既然底座被502脆化以后，干脆直接把底座给撕下来研究一下Mac键盘的机械原理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fix-macbook-keyboard/2.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从下到上依次是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;键盘电路板，用于联通电路和给LED灯通电&lt;/li&gt;
  &lt;li&gt;蝴蝶支架，原来支架是夹在电路板和底座之间的，怪不得打开键帽以后，支架无法拆卸&lt;/li&gt;
  &lt;li&gt;底座除了承担触点的功能外，主要的作用是通过四个点卡在电路板上的同时扣住支架&lt;/li&gt;
  &lt;li&gt;最上面是键帽，键帽通过卡扣卡在支架上&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过这种环环相扣的方式，完成了从电路板、触点、支架和键帽的设计，从设计上来说不得不说做的很精巧。&lt;/p&gt;

&lt;p&gt;既然知道了Mac键盘的机械结构，剩下的就是胶水选型，像502这种速干同时对塑料有腐蚀性的胶水千万不能再用。
为了能够把底座粘贴在电路板上，胶水需要满足几个条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;出口是针头形状的，这样可以精确的控制胶水，保证在薄薄的粘贴底座的同时不能晕染到触点电路上&lt;/li&gt;
  &lt;li&gt;不能腐蚀塑料，避免触点弹性塑料被腐蚀，无法回弹&lt;/li&gt;
  &lt;li&gt;慢干型的，胶水万一挤多了，还可以用吸水纸吸一下&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最终在淘宝上找到这种名字叫 B7000 的慢干精细型手机胶水。
打开是一个针头粗细的出口，挤之前用吸水纸擦干就很容易把胶水的大小范围控制在毫米级别。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fix-macbook-keyboard/3.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;修复&quot;&gt;修复&lt;/h3&gt;
&lt;p&gt;首先在淘宝上花10块买一个MacBook的底座和支架，老板可以剪给你, 如下图一所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fix-macbook-keyboard/4.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后用镊子把底座从电路板上撕下来，注意底座和支架最后需要再粘贴到笔记本上，所以撕的时候一定要小心和耐心，一点点的撕，不要把底座和支架撕坏了。最终会变成上图中图二和图三的单个零件。&lt;/p&gt;

&lt;p&gt;附一张我撕底座的残骸，看着好暴力的赶脚.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fix-macbook-keyboard/5.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;修复步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在电路板底部、左边中间、左边右边点三个直径2毫米的胶水滴，这三个位置可以有效避免胶水受压力晕染到电路板的触点上，顶部是LED的位置，不用点胶&lt;/li&gt;
  &lt;li&gt;先把蝴蝶支架和底座扣好，蝴蝶支架有小字的那一面放在底座的顶部位置&lt;/li&gt;
  &lt;li&gt;把底座的四个点对准电路板的四个凹槽按下去，并按压使胶水充分粘贴住底座和电路板&lt;/li&gt;
  &lt;li&gt;用手指头戳一下底座中间的触点，只要能够敲击字符即可&lt;/li&gt;
  &lt;li&gt;这一步很关键，先不要扣上键帽，放置底座几个小时等胶水干，要不然键帽没扣好重新扣键帽的时候，底座、支架、键帽会一起被扣下来，不要问我为什么知道，说出来都是泪&lt;/li&gt;
  &lt;li&gt;等胶水干透后，扣上键帽&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;按照上面的步骤修复后，又可以愉快的敲打键盘了。&lt;/p&gt;

&lt;p&gt;通过这次键盘拆卸安装，可以充分体验到苹果的键盘设计是多么的垃圾，一个薄如0.5毫米的铁片 + 弹性塑料就承担了千万次键盘敲击的重任，怪不得键盘会被我敲坏。&lt;/p&gt;

&lt;p&gt;但是通过这一次折腾，下次任何按键再坏掉以后，我都可以通过30元（10元底座支架、10元键帽、10元胶水）来快速修复它。&lt;/p&gt;

&lt;p&gt;世界上没有修不好的机械，只要你有一颗作死的心, 哈哈哈。&lt;/p&gt;</content><author><name></name></author><summary type="html">继上个星期我把MacBook Pro的键盘敲碎了</summary></entry><entry><title type="html">MacBook Pro的键盘被我敲碎了</title><link href="http://localhost:4000/mac/tech/2019/07/04/fuck-mackbook-keyboard.html" rel="alternate" type="text/html" title="MacBook Pro的键盘被我敲碎了" /><published>2019-07-04T00:00:00+08:00</published><updated>2019-07-04T00:00:00+08:00</updated><id>http://localhost:4000/mac/tech/2019/07/04/fuck-mackbook-keyboard</id><content type="html" xml:base="http://localhost:4000/mac/tech/2019/07/04/fuck-mackbook-keyboard.html">&lt;p&gt;都说Mac笔记本的键盘渣，最开始我一直以为只是手感差，论键盘手感，只有老款的ThinkPad的键盘手感才算过得去。&lt;/p&gt;

&lt;p&gt;在MacBook Pro上写代码的时候，能明显地感觉到MacBook Pro那可怜的键盘回弹，敲上去总是给人一种非常脆弱的感觉。
为了不把Mac笔记本的键盘敲坏，我一直小心翼翼的按键，生怕哪一天这个键盘罢工了。&lt;/p&gt;

&lt;p&gt;人算不如天算啊，MacBook Pro用了刚好一年，J这个按键已经被我敲碎了，完全没法用了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fuck-macbook-keyboard/1.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而且我有预感，其他按键过一段时间也会步J按键的后尘，为了保险，下午去了一趟苹果售后，售货人员直接说，换整个键盘3000，换一个键帽几大百。
真黑心啊，自己动手丰衣足食，我在淘宝上花了35元买了一整套键帽，等键帽回来自己动手换。&lt;/p&gt;

&lt;p&gt;在键帽到之前，我估计要背着我的IKBC机械硬盘几天了，晚上回家把机械键盘插上MacBook Pro后，完全一脸懵逼，
Mac无法正确映射IKBC的键盘布局，导致快捷键不兼容后我完全没法使用Emacs。&lt;/p&gt;

&lt;p&gt;研究了一下 Karabiner Elements 这个专业换快捷键利器，搞定了问题：&lt;/p&gt;

&lt;p&gt;首先把MacBook Pro内置的Fn和Ctrl键交换了，我喜欢左下角就是Ctrl按键的踏实感&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fuck-macbook-keyboard/2.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其次把IKBC机械键盘的左Ctrl、左Win、左Alt键做一个映射，解决MacBook Pro映射错键位的问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fuck-macbook-keyboard/3.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后设置当IKBC机械键盘插入时，禁用MacBook Pro的内置键盘，这样我就可以把机械键盘放到笔记本上敲而不会触发笔记本的内置键盘&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/fuck-macbook-keyboard/4.png&quot; alt=&quot;MacBook Pro-Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过上面三个步骤的设置后，我又可以非常流畅的使用Emacs了，忍受了一年MacBook Pro的垃圾键盘，终于又体会到机械键盘写代码的快乐了。&lt;/p&gt;

&lt;p&gt;我估计等MacBook Pro键帽换好以后，我还是会背着机械键盘走天下。&lt;/p&gt;</content><author><name></name></author><summary type="html">都说Mac笔记本的键盘渣，最开始我一直以为只是手感差，论键盘手感，只有老款的ThinkPad的键盘手感才算过得去。</summary></entry><entry><title type="html">highlight-matching-tag.el 实时高亮匹配标签</title><link href="http://localhost:4000/emacs/2019/06/27/highlight-matching-tag.html" rel="alternate" type="text/html" title="highlight-matching-tag.el 实时高亮匹配标签" /><published>2019-06-27T00:00:00+08:00</published><updated>2019-06-27T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/06/27/highlight-matching-tag</id><content type="html" xml:base="http://localhost:4000/emacs/2019/06/27/highlight-matching-tag.html">&lt;p&gt;昨天花了一个小时给Emacs写了实时重命名Tag的插件&lt;a href=&quot;https://manateelazycat.github.io/emacs/2019/06/26/instant-rename-tag.html&quot;&gt;instant-rename-tag&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今天就在想，能否基于同样原理写一个实时高亮匹配标签的插件呢？&lt;/p&gt;

&lt;h3 id=&quot;highlight-matching-tagel-的原理&quot;&gt;highlight-matching-tag.el 的原理&lt;/h3&gt;

&lt;p&gt;highlight-matching-tag的原理和instant-rename-tag完全是一样的，只是绑定了不同的事件hook&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;post-command-hook&lt;/code&gt; 监听光标移动事件，如果当前处于 &lt;code class=&quot;highlighter-rouge&quot;&gt;web-mode&lt;/code&gt; 模式时继续处理&lt;/li&gt;
  &lt;li&gt;如果光标在Tag区域，找到匹配的光标，然后用 Overlay 高亮匹配的标签&lt;/li&gt;
  &lt;li&gt;如果光标不在Tag区域，隐藏标签高亮&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/highlight-matching-tag/highlight-matching-tag.gif&quot; alt=&quot;highlight-matching-tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装方法见&lt;a href=&quot;https://github.com/manateelazycat/highlight-matching-tag&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;
&lt;p&gt;安装好只用调用命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;(highlight-matching-tag 1)&lt;/code&gt; 即可&lt;/p&gt;</content><author><name></name></author><summary type="html">昨天花了一个小时给Emacs写了实时重命名Tag的插件instant-rename-tag</summary></entry><entry><title type="html">instant-rename-tag.el 实时修改Tag名</title><link href="http://localhost:4000/emacs/2019/06/26/instant-rename-tag.html" rel="alternate" type="text/html" title="instant-rename-tag.el 实时修改Tag名" /><published>2019-06-26T00:00:00+08:00</published><updated>2019-06-26T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/06/26/instant-rename-tag</id><content type="html" xml:base="http://localhost:4000/emacs/2019/06/26/instant-rename-tag.html">&lt;p&gt;最近在研究VSCode好用的功能，希望通过一点点的努力, 把VSCode好的功能吸收到Emacs。&lt;/p&gt;

&lt;p&gt;说到VSCode，说它是支持Web编程最好的IDE一点也不为过，其中实时修改Tag名字的功能非常好用。&lt;/p&gt;

&lt;p&gt;可惜的是，Emacs一直都没有好用的实时修改Tag的功能，即使最强大的 web-mode 也需要从 minibuffer 中读取新的Tag，视线要在光标处和minibuffer来回跳动，不够爽。&lt;/p&gt;

&lt;p&gt;以前类似的插件在原理上总是希望修改Tag的时候，实时的计算匹配的Tag区域并同步更新，这样的实现原理是有问题:&lt;/p&gt;

&lt;p&gt;因为不管是 sgml-mode 还是 web-mode, 一旦发现Tag不匹配，就很难找到匹配Tag区域，究其原因是Emacs找到匹配的Tag区域是基于正则查找, 所以一旦Tag无法匹配，实时修改Tag的功能实现就很困难，而且在复杂的Emacs插件环境中特别容易出错。&lt;/p&gt;

&lt;h3 id=&quot;instant-rename-tagel-的原理&quot;&gt;instant-rename-tag.el 的原理&lt;/h3&gt;

&lt;p&gt;instant-rename-tag 认识到上面的问题，从实现上放弃了Tag实时匹配查找的策略，而是用下面的步骤来实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;重命名动作触发的时候，根据 Open Tag 还是 Close Tag的位置，找到匹配的Tag区域&lt;/li&gt;
  &lt;li&gt;用 Overlay 来保存 Open Tag 和 Close Tag 的区域，一旦保存好以后，就不再进行任何Tag匹配的搜索&lt;/li&gt;
  &lt;li&gt;监控光标插入，如果当前光标是在 Tag Overlay 区域修改，比如 &amp;lt;div&amp;gt; Tag中修改，会去找 &amp;lt;/div&amp;gt; 的 Overlay&lt;/li&gt;
  &lt;li&gt;找到对应的 Tag Overlay, 同步其内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样只在重命名启动的时候查找一下 Tag 的区域，后面只是简单的光标监控和内容同步，既实现了实时改名的功能，又不会因为Tag不匹配产生很多乱改用户buffer的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/instant-rename-tag/instant-rename-tag.gif&quot; alt=&quot;instant-rename-tag&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装方法见&lt;a href=&quot;https://github.com/manateelazycat/instant-rename-tag&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;
&lt;p&gt;使用方法很简单, 绑定按键到 &lt;code class=&quot;highlighter-rouge&quot;&gt;instant-rename-tag&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;想修改Tag名字的时候，调用一次 instant-rename-tag, 修改完成后只用把光标移动到非Tag区域继续编辑，刚刚重命名的区域会自动取消标记。&lt;/p&gt;</content><author><name></name></author><summary type="html">最近在研究VSCode好用的功能，希望通过一点点的努力, 把VSCode好的功能吸收到Emacs。</summary></entry><entry><title type="html">smart-align.el 代码自动对齐插件</title><link href="http://localhost:4000/emacs/2019/06/24/smart-align.html" rel="alternate" type="text/html" title="smart-align.el 代码自动对齐插件" /><published>2019-06-24T00:00:00+08:00</published><updated>2019-06-24T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/06/24/smart-align</id><content type="html" xml:base="http://localhost:4000/emacs/2019/06/24/smart-align.html">&lt;p&gt;像VSCode和很多IDE都具备快速对齐赋值表达式的功能。&lt;/p&gt;

&lt;p&gt;Emacs其实有更强大的 align-regexp 功能，可以让用户对选中的内容进行自定义正则对齐。
只要正则表达式玩的溜，最后实现的功能比VSCode等IDE还要强大。&lt;/p&gt;

&lt;p&gt;比如 Emacs 中要进行对齐操作，一般需要三个步骤:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;选中一段代码区域&lt;/li&gt;
  &lt;li&gt;调用 align-regexp 命令&lt;/li&gt;
  &lt;li&gt;写入需要对齐的赋值符号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是在实际编程中，大部分都是对齐赋值表达式，赋值的符号一般都是 = 或者 :
并不会有非常复杂的规则需要开发者去编写正则表达式完成对齐操作。
所以这时候 Emacs 的步骤就非常繁琐，特别是还需要手动选择需要对齐的代码区域，用户体验非常不好。&lt;/p&gt;

&lt;p&gt;针对上面的情况，写了 smart-align 这个插件，会自动选择当前光标处的代码块，一键就可以自动对齐代码块内的所有内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/pics/smart-align/smart-align.gif&quot; alt=&quot;smart-align&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装方法见&lt;a href=&quot;https://github.com/manateelazycat/smart-align&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;
&lt;p&gt;使用方法很简单, 绑定按键到 &lt;code class=&quot;highlighter-rouge&quot;&gt;smart-align&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码贡献&quot;&gt;代码贡献&lt;/h3&gt;
&lt;p&gt;现在代码实现只是简单的用 &lt;code class=&quot;highlighter-rouge&quot;&gt;backward-up-list&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;up-list&lt;/code&gt; 自动选择光标外的一层语法块，
如果语法块内每一行都是赋值表达式，这个插件会工作的非常好。&lt;/p&gt;

&lt;p&gt;但是如果语法块内有某一行不是赋值表达式， &lt;code class=&quot;highlighter-rouge&quot;&gt;align-regexp&lt;/code&gt; 函数就会失效，无法对代码进行自动对齐。&lt;/p&gt;

&lt;p&gt;正确的思路应该是在语法块内进一步搜索来进一步定位包含 = 或者 : 的子语法块范围，再依次传给 &lt;code class=&quot;highlighter-rouge&quot;&gt;align-regexp&lt;/code&gt;
欢迎各大高手来一起 &lt;a href=&quot;https://github.com/manateelazycat/smart-align/edit/master/smart-align.el&quot;&gt;完善&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">像VSCode和很多IDE都具备快速对齐赋值表达式的功能。</summary></entry><entry><title type="html">AwesomeTab支持图标显示了</title><link href="http://localhost:4000/emacs/2019/06/23/awesome-tab-support-icon.html" rel="alternate" type="text/html" title="AwesomeTab支持图标显示了" /><published>2019-06-23T00:00:00+08:00</published><updated>2019-06-23T00:00:00+08:00</updated><id>http://localhost:4000/emacs/2019/06/23/awesome-tab-support-icon</id><content type="html" xml:base="http://localhost:4000/emacs/2019/06/23/awesome-tab-support-icon.html">&lt;p&gt;自从发布 &lt;a href=&quot;https://github.com/manateelazycat/awesome-tab&quot;&gt;AwesomeTab&lt;/a&gt; 这个Emacs最好的标签插件以后，很多社区的高手陆续地在给这个项目贡献建议和补丁。&lt;/p&gt;

&lt;p&gt;头两天接到一个国外开发者的 &lt;a href=&quot;https://github.com/manateelazycat/awesome-tab/issues/34&quot;&gt;issue&lt;/a&gt;, 提出了想在标签上显示图标的功能，今天早上思考了5分钟, 写了一个补丁: &lt;a href=&quot;https://github.com/manateelazycat/awesome-tab/commit/ae98cef5c9fe2b8674c705f1772400f0caf10a74&quot;&gt;让AwesomeTab支持图标渲染&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;只要 &lt;a href=&quot;https://github.com/domtronn/all-the-icons.el&quot;&gt;AllTheIcons&lt;/a&gt; 这个图标插件安装好以后， AwesomeTab会自动在标签上渲染对应的文件图标。&lt;/p&gt;

&lt;p&gt;最终的效果图如下：
&lt;img src=&quot;http://localhost:4000/pics/awesome-tab/support-icons.png&quot; alt=&quot;AwesomeTab&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这就是开源社区的魅力，每天只做一点点，滴水石穿就能做出非常好的软件。&lt;/p&gt;</content><author><name></name></author><summary type="html">自从发布 AwesomeTab 这个Emacs最好的标签插件以后，很多社区的高手陆续地在给这个项目贡献建议和补丁。</summary></entry></feed>